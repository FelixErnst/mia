#' Loading a biom file
#'
#' For convenience a few functions are available to convert data from a
#' \sQuote{biom} file or object into a
#' \code{\link[TreeSummarizedExperiment:TreeSummarizedExperiment-class]{TreeSummarizedExperiment}}
#'
#' @param file biom file location
#' 
#' @param removeTaxaPrefixes \code{TRUE} or \code{FALSE}: Should
#' taxonomic prefixes be removed? (default \code{removeTaxaPrefixes = FALSE})
#' 
#' @param rankFromPrefix \code{TRUE} or \code{FALSE}: If file does not have
#' taxonomic ranks on feature table, should they be scraped from prefixes?
#' (default \code{rankFromPrefix = FALSE})
#' 
#' @param clean.taxa.names \code{character} or \code{regex}: If file have
#' some taxonomic character naming artifacts to be removed. Additionally
#' when \code{clean.taxa.names = "auto"} automatically artifacts are detected
#' and removed. Otherwise \code{clean.taxa.names = NULL} no cleaning is performed.
#' (default \code{clean.taxa.names = "auto"})
#' 
#' @param ... optional arguments (not used).
#' 
#' @return An object of class
#'   \code{\link[TreeSummarizedExperiment:TreeSummarizedExperiment-class]{TreeSummarizedExperiment}}
#'
#' @name makeTreeSEFromBiom
#' @seealso
#' \code{\link[=makeTreeSEFromPhyloseq]{makeTreeSEFromPhyloseq}}
#' \code{\link[=makeTreeSEFromDADA2]{makeTreeSEFromDADA2}}
#' \code{\link[=loadFromQIIME2]{loadFromQIIME2}}
#' \code{\link[=loadFromMothur]{loadFromMothur}}
#'
#' @examples
#' if(requireNamespace("biomformat")) {
#'   library(biomformat)
#'   # load from file
#'   rich_dense_file  = system.file("extdata", "rich_dense_otu_table.biom",
#'                                  package = "biomformat")
#'   se <- loadFromBiom(rich_dense_file, removeTaxaPrefixes = TRUE,
#'                     rankFromPrefix = TRUE)
#'                     
#'   # load from object
#'   x1 <- biomformat::read_biom(rich_dense_file)
#'   se <- makeTreeSEFromBiom(x1)
#'   # Convert SE to TreeSE
#'   tse <- as(se, "TreeSummarizedExperiment")
#'   tse
#'   
#'   # Cleaning artifacts from Taxonomy data
#'   f <- system.file("extdata/testdata/Aggregated_humanization2.biom",
#'                   package="mia")
#'   biom_object <- biomformat::read_biom(f)
#'   tse <- makeTreeSEFromBiom(biom_object,
#'                             removeTaxaPrefixes=TRUE,
#'                             rankFromPrefix=TRUE,
#'                             clean.taxa.names = "auto")
#'   tse
#' }
NULL

#' @rdname makeTreeSEFromBiom
#'
#' @export
loadFromBiom <- function(file, ...) {
    .require_package("biomformat")
    biom <- biomformat::read_biom(file)
    makeTreeSEFromBiom(biom, ...)
}

#' @rdname makeTreeSEFromBiom
#'
#' @param obj object of type \code{\link[biomformat:read_biom]{biom}}
#'
#' @export
#' @importFrom S4Vectors make_zero_col_DFrame DataFrame
#' @importFrom dplyr %>%
makeTreeSEFromBiom <- function(
        obj, removeTaxaPrefixes = FALSE, rankFromPrefix = FALSE,
        clean.taxa.names="auto", ...){
    # input check
    .require_package("biomformat")
    if(!is(obj,"biom")){
        stop("'obj' must be a 'biom' object", call. = FALSE)
    }
    if( !.is_a_bool(removeTaxaPrefixes) ){
        stop("'removeTaxaPrefixes' must be TRUE or FALSE.", call. = FALSE)
    }
    if( !.is_a_bool(rankFromPrefix) ){
        stop("'rankFromPrefix' must be TRUE or FALSE.", call. = FALSE)
    }
    if( !is.null(clean.taxa.names) && !.is_non_empty_character(clean.taxa.names) ){
        stop("'clean.taxa.names' must be a character, NULL or 'auto'.", call. = FALSE)
    }
    #
    counts <- as(biomformat::biom_data(obj), "matrix")
    sample_data <- biomformat::sample_metadata(obj)
    feature_data <- biomformat::observation_metadata(obj)
    
    # colData is initialized with empty tables with rownames if it is NULL
    if( is.null(sample_data) ){
        sample_data <- S4Vectors::make_zero_col_DFrame(ncol(counts))
        rownames(sample_data) <- colnames(counts)
    # Otherwise convert it into correct format if it is a list
    } else if( is(sample_data, "list") ){
        # Get the maximum length of list
        max_length <- max( lengths(sample_data) )
        # Get the column names from the taxa info that has all the columns that occurs
        # in the data
        colnames <- names( head( sample_data[ lengths(sample_data) == 
                                                  max_length ], 1)[[1]] )
        # Append the data with NAs if some samples do not have all the info
        sample_data <- lapply(sample_data, function(x){
            length(x) <- max_length 
            return(x)
        })
        # Create a data.frame from the list
        sample_data <- do.call(rbind, sample_data)
        # Add correct colnames
        colnames(sample_data) <- colnames
    }
    # rowData is initialized with empty tables with rownames if it is NULL
    if( is.null(feature_data) ){
        feature_data <- S4Vectors::make_zero_col_DFrame(nrow(counts))
        rownames(feature_data) <- rownames(counts)
    # Otherwise convert it into correct format if it is a list
    } else if( is(feature_data, "list") ){
        # Clean feature_data from possible character artifacts
        feature_data <- .detect_taxa_artifacts_and_clean(feature_data,
                                                         clean.taxa.names)
        # Taxonomy rank names
        if (is.null(names(feature_data))) {
            # Assign temporary ones if they do not exist 
            colnames <- paste0("taxonomy", seq_along(feature_data))
        } else {
            # Get them if they exist
            colnames <- names(feature_data)
        }

        # Feature data is a list of taxa info
        # Get the maximum length of list
        max_length <- max( lengths(feature_data) )
        
        # Convert the list so that all individual taxa info have the max length
        # of the list objects. All vectors are appended with NAs, if they do not
        # have all the levels. E.g., if only Kingdom level is found, all lower
        # ranks are now NA
        feature_data <- lapply(feature_data, function(x){
            length(x) <- max_length 
            return(x)
        })
        # Create a data.frame from the list
        feature_data <- do.call(rbind, feature_data)
        # Transposing feature_data and make it DFrame object
        feature_data <- DataFrame(t(feature_data))
        # Add correct colnames
        colnames(feature_data) <- colnames
    # Otherwise if it is already a data.frame clean from artifacts
    } else if (is(feature_data, "data.frame")) {
        # Clean feature_data from possible character artifacts
        feature_data <- DataFrame(.detect_taxa_artifacts_and_clean(feature_data,
                                                         clean.taxa.names))
    }
    
    # Replace taxonomy ranks with ranks found based on prefixes
    if( rankFromPrefix && all(
        unlist(lapply(colnames(feature_data),
                      function(x) !x %in% TAXONOMY_RANKS)))){
        # Find ranks
        ranks <- lapply(colnames(feature_data),
                        .replace_colnames_based_on_prefix, x=feature_data)
        # Replace old ranks with found ranks
        colnames(feature_data) <- unlist(ranks)
    }
    
    # Remove prefixes if specified and rowData includes info
    if(removeTaxaPrefixes && ncol(feature_data) > 0){
        # Patterns for superkingdom, domain, kingdom, phylum, class, order, family,
        # genus, species
        patterns <- "sk__|([dkpcofgs]+)__"
        feature_data <- lapply(
            feature_data,
            gsub, pattern = patterns, replacement = "")
        feature_data <- as.data.frame(feature_data)
    }
    
    # Adjust row and colnames
    rownames(counts) <- rownames(feature_data) <- biomformat::rownames(obj)
    colnames(counts) <- rownames(sample_data) <- biomformat::colnames(obj)
    
    # Convert into DataFrame
    sample_data <- DataFrame(sample_data)
    feature_data <- DataFrame(feature_data)
    # Convert into list
    assays <- SimpleList(counts = counts)
    
    # Create TreeSE
    tse <- TreeSummarizedExperiment(
        assays = assays,
        colData = sample_data,
        rowData = feature_data)
    return(tse)
}

####################### makeTreeSummarizedExperimentFromBiom #######################
#' @param obj object of type \code{\link[biomformat:read_biom]{biom}}
#' @rdname makeTreeSEFromBiom
#' @export
makeTreeSummarizedExperimentFromBiom <- function(obj, ...){
    makeTreeSEFromBiom(obj, ...)
}

################################ HELP FUNCTIONS ################################
# Find taxonomy rank based on prefixes. If found, return
# corresponding rank. Otherwise, return the original
# rank that is fed to function.
.replace_colnames_based_on_prefix <- function(colname, x){
    # Get column
    col = x[ , colname]
    # List prefixes
    prefixes <- c(
        "^d__",
        "^k__",
        "^p__",
        "^c__",
        "^o__",
        "^f__",
        "^g__",
        "^s__"
    )
    # Find which prefix is found from each column value, if none.
    found_rank <- lapply(
        prefixes, FUN = function(pref){all(grepl(pattern=pref, col))})
    found_rank <- unlist(found_rank)
    # If only one prefix was found (like it should be), get the corresponding
    # rank name.
    if( sum(found_rank) ){
        colname <- TAXONOMY_RANKS[found_rank]
        # Make it capitalized
        colname <- paste0(toupper(substr(colname, 1, 1)),
                          substr(colname, 2, nchar(colname)))
    }
    return(colname)    
}

# Detect and clean non wanted characters from Taxonomy data if needed.
.detect_taxa_artifacts_and_clean <- function(x, patterns) {
    
    # No cleaning if NULL
    if (!is.null(patterns)) {
        # Automatic cleaning
        if (patterns=="auto") {
            # General regex pattern that corresponds to taxonomy namings
            PATTERN <- "[[:alnum:]]|-|_|\\[|\\]|,|;\\||[[:space:]]"
            patterns <- .detect_taxa_artifacts(x, PATTERN, invert=TRUE)
            # Clean from artifacts if found
            if (patterns!="") {
                x <- .clean_from_artifacts(x, patterns)
            }
        # Clean with the character or regex provided
        } else {
            pattern <- .detect_taxa_artifacts(x, patterns=patterns)
            # patterns provided not found
            if (pattern=="") {
                warning("The '", patterns, "' provided at 'clean.taxa.names' were
                    not found in rowData.",
                        call. = FALSE)
                # patterns found and cleaned
            } else {
                x <- .clean_from_artifacts(x, pattern)
            }
        }
    }
    
    return(x)
}

# Helper function for detecting taxa artifacts 
.detect_taxa_artifacts <- function(
        x,
        patterns,
        invert=FALSE) {
    if (is(x, "list")) {
        patterns <- lapply(x, function(x_sub) {
            grep(patterns,
                 x_sub[[1]] %>% stringr::str_split("") %>% unlist(),
                 invert = invert, value = TRUE) %>% unique()
        }) %>% unlist() %>% unique() %>% paste0(collapse = "")
    } else if (is(x, "data.frame")){
        patterns <- apply(x, 2, function(x_sub) {
            grep(patterns,
                 x_sub %>% stringr::str_split("") %>% unlist(),
                 invert = invert, value = TRUE) %>% unique()
        }) %>% unlist() %>% unique() %>% paste0(collapse = "")
    }
    return(patterns)
}

.clean_from_artifacts <- function(x, patterns) {
    if (is(x, "list")) {
        x <- lapply(x, gsub, pattern = patterns, replacement = "")
    } else if (is(x, "data.frame")) {
        x <- apply(x, 2, gsub, pattern = patterns, replacement = "")
    }
    # warn what was cleaned
    warning("The following artifacts: '", patterns, "' were cleaned from 
                    rowData.", call. = FALSE)
    return(x)
}