% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/agglomerate.R, R/getPrevalence.R,
%   R/splitByRanks.R
\name{agglomerate-methods}
\alias{agglomerate-methods}
\alias{agglomerateByRank}
\alias{agglomerateByVariable}
\alias{agglomerateByRank,SummarizedExperiment-method}
\alias{agglomerateByVariable,SummarizedExperiment-method}
\alias{agglomerateByVariable,TreeSummarizedExperiment-method}
\alias{agglomerateByRank,SingleCellExperiment-method}
\alias{agglomerateByRank,TreeSummarizedExperiment-method}
\alias{agglomerateByPrevalence}
\alias{agglomerateByPrevalence,SummarizedExperiment-method}
\alias{agglomerateByRanks}
\alias{agglomerateByRanks,SummarizedExperiment-method}
\alias{agglomerateByRanks,SingleCellExperiment-method}
\alias{agglomerateByRanks,TreeSummarizedExperiment-method}
\alias{splitByRanks}
\alias{unsplitByRanks}
\alias{unsplitByRanks,SingleCellExperiment-method}
\alias{unsplitByRanks,TreeSummarizedExperiment-method}
\title{Agglomerate or merge data using taxonomic information}
\usage{
agglomerateByRank(x, ...)

agglomerateByVariable(x, ...)

\S4method{agglomerateByRank}{SummarizedExperiment}(
  x,
  rank = taxonomyRanks(x)[1],
  na.rm = TRUE,
  empty.fields = c(NA, "", " ", "\\t", "-", "_"),
  ...
)

\S4method{agglomerateByVariable}{SummarizedExperiment}(x, MARGIN, f, ...)

\S4method{agglomerateByVariable}{TreeSummarizedExperiment}(
  x,
  MARGIN,
  f,
  update.tree = mergeTree,
  mergeTree = FALSE,
  ...
)

\S4method{agglomerateByRank}{SingleCellExperiment}(
  x,
  ...,
  altexp = NULL,
  altexp.rm = strip_altexp,
  strip_altexp = TRUE
)

\S4method{agglomerateByRank}{TreeSummarizedExperiment}(
  x,
  ...,
  update.tree = agglomerateTree,
  agglomerate.tree = agglomerateTree,
  agglomerateTree = FALSE
)

agglomerateByPrevalence(x, ...)

\S4method{agglomerateByPrevalence}{SummarizedExperiment}(
  x,
  rank = NULL,
  other.label = other_label,
  other_label = "Other",
  ...
)

agglomerateByRanks(x, ...)

\S4method{agglomerateByRanks}{SummarizedExperiment}(
  x,
  ranks = taxonomyRanks(x),
  na.rm = TRUE,
  as.list = FALSE,
  ...
)

\S4method{agglomerateByRanks}{SingleCellExperiment}(
  x,
  ranks = taxonomyRanks(x),
  na.rm = TRUE,
  as.list = FALSE,
  ...
)

\S4method{agglomerateByRanks}{TreeSummarizedExperiment}(
  x,
  ranks = taxonomyRanks(x),
  na.rm = TRUE,
  as.list = FALSE,
  ...
)

splitByRanks(x, ...)

unsplitByRanks(x, ...)

\S4method{unsplitByRanks}{SingleCellExperiment}(
  x,
  ranks = taxonomyRanks(x),
  keep.dimred = keep_reducedDims,
  keep_reducedDims = FALSE,
  ...
)

\S4method{unsplitByRanks}{TreeSummarizedExperiment}(
  x,
  ranks = taxonomyRanks(x),
  keep.dimred = keep_reducedDims,
  keep_reducedDims = FALSE,
  ...
)
}
\arguments{
\item{x}{a
\code{\link[SummarizedExperiment:SummarizedExperiment-class]{SummarizedExperiment}}
object}

\item{...}{arguments passed to \code{agglomerateByRank} function for
\code{SummarizedExperiment} objects and other functions.
See \code{\link[=agglomerate-methods]{agglomerateByRank}} for more details.}

\item{rank}{a single character defining a taxonomic rank. Must be a value of
\code{taxonomyRanks()} function.}

\item{na.rm}{\code{TRUE} or \code{FALSE}: Should taxa with an empty rank be
removed? Use it with caution, since results with NA on the selected rank
will be dropped. This setting can be tweaked by defining
\code{empty.fields} to your needs. (default: \code{na.rm = TRUE})}

\item{empty.fields}{a \code{character} value defining, which values should be
regarded as empty. (Default: \code{c(NA, "", " ", "\t")}). They will be
removed if \code{na.rm = TRUE} before agglomeration.}

\item{MARGIN}{A character value for selecting if data is merged
row-wise / for features ('rows') or column-wise / for samples ('cols').
Must be \code{'rows'} or \code{'cols'}.}

\item{f}{A factor for merging. Must be the same length as
\code{nrow(x)/ncol(x)}. Rows/Cols corresponding to the same level will be
merged. If \code{length(levels(f)) == nrow(x)/ncol(x)}, \code{x} will be
returned unchanged.}

\item{update.tree}{\code{TRUE} or \code{FALSE}: Should
\code{rowTree()} also be merged? (Default: \code{update.tree = FALSE})}

\item{mergeTree}{Deprecated. Use \code{update.tree} instead.}

\item{altexp}{String or integer scalar specifying an alternative experiment
containing the input data.}

\item{altexp.rm}{\code{TRUE} or \code{FALSE}: Should alternative
experiments be removed prior to agglomeration? This prevents to many
nested alternative experiments by default (default:
\code{altexp.rm = TRUE})}

\item{strip_altexp}{Deprecated. Use \code{altexp.rm} instead.}

\item{agglomerate.tree}{Deprecated. Use \code{update.tree} instead.}

\item{agglomerateTree}{Deprecated. Use \code{update.tree} instead.}

\item{other.label}{A single \code{character} valued used as the label for the
summary of non-prevalent taxa. (default: \code{other.label = "Other"})}

\item{other_label}{Deprecated. use \code{other.label} instead.}

\item{ranks}{a character vector defining taxonomic ranks. Must all be values
of \code{taxonomyRanks()} function.}

\item{as.list}{\code{TRUE} or \code{FALSE}: Should the list of
\code{SummarizedExperiment} objects be returned by the function
\code{agglomerateByRanks} as a SimpleList or stored in altExps?
(default: \code{as.list = FALSE})}

\item{keep.dimred}{\code{TRUE} or \code{FALSE}: Should the
\code{reducedDims(x)} be transferred to the result? Please note, that this
breaks the link between the data used to calculate the reduced dims.
(default: \code{keep.dimred = FALSE})}

\item{keep_reducedDims}{Deprecated. Use \code{keep.dimred} instead.}
}
\value{
\code{agglomerateByRank} returns a taxonomically-agglomerated,
optionally-pruned object of the same class as \code{x}.
\code{agglomerateByVariable} returns an object of the same class as \code{x}
with the specified entries merged into one entry in all relevant components.
\code{agglomerateByRank} returns a taxonomically-agglomerated,
optionally-pruned object of the same class as \code{x}.

\code{agglomerateByPrevalence} returns a taxonomically-agglomerated object
of the same class as x and based on prevalent taxonomic results.

For \code{agglomerateByRanks}:
If \code{as.list = TRUE} : \code{SummarizedExperiment} objects in a
\code{SimpleList}
If \code{as.list = FALSE} : The \code{SummarizedExperiment} passed as a
parameter and now containing the \code{SummarizedExperiment} objects in its
altExps

For \code{unsplitByRanks}: \code{x}, with \code{rowData} and \code{assay}
data replaced by the unsplit data. \code{colData} of x is kept as well
and any existing \code{rowTree} is dropped as well, since existing
\code{rowLinks} are not valid anymore.
}
\description{
Agglomeration functions can be used to sum-up data based on specific criteria
such as taxonomic ranks, variables or prevalence.

\code{agglomerateByRanks} takes a \code{SummarizedExperiment}, splits it along the
taxonomic ranks, aggregates the data per rank, converts the input to a
\code{SingleCellExperiment} objects and stores the aggregated data as
alternative experiments. \code{unsplitByRanks} takes these alternative
experiments and flattens them again into a single
\code{SummarizedExperiment}.
}
\details{
\code{agglomerateByRank} can be used to sum up data based on associations
with certain taxonomic ranks, as defined in \code{rowData}. Only available
\code{\link{taxonomyRanks}} can be used.

\code{agglomerateByVariable} merges data on rows or columns of a
\code{SummarizedExperiment} as defined by a \code{factor} alongside the
chosen dimension. This function allows agglomeration of data based on other
variables than taxonomy ranks.
Metadata from the \code{rowData} or \code{colData} are
retained as defined by \code{archetype}.
\code{\link[SummarizedExperiment:SummarizedExperiment-class]{assay}} are
agglomerated, i.e. summed up. If the assay contains values other than counts
or absolute values, this can lead to meaningless values being produced.

Agglomeration sums up the values of assays at the specified taxonomic level. With
certain assays, e.g. those that include binary or negative values, this summing
can produce meaningless values. In those cases, consider performing agglomeration
first, and then applying the transformation afterwards.

\code{agglomerateByVariable} works similarly to
\code{\link[scuttle:sumCountsAcrossFeatures]{sumCountsAcrossFeatures}}.
However, additional support for \code{TreeSummarizedExperiment} was added and
science field agnostic names were used. In addition the \code{archetype}
argument lets the user select how to preserve row or column data.

For merge data of assays the function from \code{scuttle} are used.

\code{agglomerateByPrevalence} sums up the values of assays at the taxonomic
level specified by \code{rank} (by default the highest taxonomic level
available) and selects the summed results that exceed the given population
prevalence at the given detection level. The other summed values (below the
threshold) are agglomerated in an additional row taking the name indicated by
\code{other.label} (by default "Other").

\code{agglomerateByRanks} will use by default all available taxonomic ranks, but
this can be controlled by setting \code{ranks} manually. \code{NA} values
are removed by default, since they would not make sense, if the result
should be used for \code{unsplitByRanks} at some point. The input data
remains unchanged in the returned \code{SingleCellExperiment} objects.

\code{unsplitByRanks} will remove any \code{NA} value on each taxonomic rank
so that no ambiguous data is created. In additional, a column
\code{taxonomicLevel} is created or overwritten in the \code{rowData} to
specify from which alternative experiment this originates from. This can also
be used for \code{\link[SingleCellExperiment:splitAltExps]{splitAltExps}} to
split the result along the same factor again. The input data from the base
objects is not returned, only the data from the \code{altExp()}. Be aware that
changes to \code{rowData} of the base object are not returned, whereas only
the \code{colData} of the base object is kept.
}
\examples{

### Agglomerate data based on taxonomic information

data(GlobalPatterns)
# print the available taxonomic ranks
colnames(rowData(GlobalPatterns))
taxonomyRanks(GlobalPatterns)

# agglomerate at the Family taxonomic rank
x1 <- agglomerateByRank(GlobalPatterns, rank="Family")
## How many taxa before/after agglomeration?
nrow(GlobalPatterns)
nrow(x1)

# agglomerate the tree as well
x2 <- agglomerateByRank(GlobalPatterns, rank="Family",
                       update.tree = TRUE)
nrow(x2) # same number of rows, but
rowTree(x1) # ... different
rowTree(x2) # ... tree

# If assay contains binary or negative values, summing might lead to
# meaningless values, and you will get a warning. In these cases, you might
# want to do agglomeration again at chosen taxonomic level.
tse <- transformAssay(GlobalPatterns, method = "pa")
tse <- agglomerateByRank(tse, rank = "Genus")
tse <- transformAssay(tse, method = "pa")

# removing empty labels by setting na.rm = TRUE
sum(is.na(rowData(GlobalPatterns)$Family))
x3 <- agglomerateByRank(GlobalPatterns, rank="Family", na.rm = TRUE)
nrow(x3) # different from x2

# Because all the rownames are from the same rank, rownames do not include
# prefixes, in this case "Family:".
print(rownames(x3[1:3,]))

# To add them, use getTaxonomyLabels function.
rownames(x3) <- getTaxonomyLabels(x3, with.rank = TRUE)
print(rownames(x3[1:3,]))

# use 'empty.ranks.rm' to remove columns that include only NAs
x4 <- agglomerateByRank(GlobalPatterns, rank="Phylum",
                        empty.ranks.rm = TRUE)
head(rowData(x4))

# If the assay contains NAs, you might want to consider replacing them,
# since summing-up NAs lead to NA
x5 <- GlobalPatterns
# Replace first value with NA
assay(x5)[1,1] <- NA
x6 <- agglomerateByRank(x5, "Kingdom")
head( assay(x6) )
# Replace NAs with 0. This is justified when we are summing-up counts.
assay(x5)[ is.na(assay(x5)) ] <- 0
x6 <- agglomerateByRank(x5, "Kingdom")
head( assay(x6) )

## Look at enterotype dataset...
data(enterotype)
## Print the available taxonomic ranks. Shows only 1 available rank,
## not useful for agglomerateByRank
taxonomyRanks(enterotype)

### Merge TreeSummarizedExperiments on rows and columns

data(esophagus)
esophagus
plot(rowTree(esophagus))
# get a factor for merging
f <- factor(regmatches(rownames(esophagus),
                       regexpr("^[0-9]*_[0-9]*",rownames(esophagus))))
merged <- agglomerateByVariable(esophagus, MARGIN = "rows", f,
                                update.tree = TRUE)
plot(rowTree(merged))
#
data(GlobalPatterns)
GlobalPatterns
merged <- agglomerateByVariable(GlobalPatterns, MARGIN = "cols",
                                colData(GlobalPatterns)$SampleType)
merged
## Data can be aggregated based on prevalent taxonomic results
tse <- GlobalPatterns
tse <- agglomerateByPrevalence(tse,
                              rank = "Phylum",
                              detection = 1/100,
                              prevalence = 50/100,
                              as.relative = TRUE)

tse

# Here data is aggregated at the taxonomic level "Phylum". The five phyla
# that exceed the population prevalence threshold of 50/100 represent the
# five first rows of the assay in the aggregated data. The sixth and last row
# named by default "Other" takes the summed up values of all the other phyla
# that are below the prevalence threshold.

assay(tse)[,1:5]

data(GlobalPatterns)
# print the available taxonomic ranks
taxonomyRanks(GlobalPatterns)

# agglomerateByRanks
# 
tse <- agglomerateByRanks(GlobalPatterns)
altExps(tse)
altExp(tse,"Kingdom")
altExp(tse,"Species")

# unsplitByRanks
tse <- unsplitByRanks(tse)
tse

}
\seealso{
\code{\link[=splitOn]{splitOn}}
\code{\link[=unsplitOn]{unsplitOn}}
\code{\link[=agglomerate-methods]{agglomerateByVariable}},
\code{\link[scuttle:sumCountsAcrossFeatures]{sumCountsAcrossFeatures}},
\code{\link[=agglomerate-methods]{agglomerateByRank}},
\code{\link[SingleCellExperiment:altExps]{altExps}},
\code{\link[SingleCellExperiment:splitAltExps]{splitAltExps}}
}
