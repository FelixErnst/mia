% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/agglomerate.R
\name{agglomerate-methods}
\alias{agglomerate-methods}
\alias{agglomerateByRank}
\alias{mergeFeaturesByRank}
\alias{agglomerateByVariable}
\alias{agglomerateByRank,SummarizedExperiment-method}
\alias{agglomerateByVariable,SummarizedExperiment-method}
\alias{agglomerateByVariable,TreeSummarizedExperiment-method}
\alias{mergeFeaturesByRank,SummarizedExperiment-method}
\alias{agglomerateByRank,SingleCellExperiment-method}
\alias{mergeFeaturesByRank,SingleCellExperiment-method}
\alias{agglomerateByRank,TreeSummarizedExperiment-method}
\alias{mergeFeaturesByRank,TreeSummarizedExperiment-method}
\title{Agglomerate or merge data using taxonomic information}
\usage{
agglomerateByRank(x, ...)

agglomerateByVariable(x, ...)

mergeFeaturesByRank(x, ...)

\S4method{agglomerateByRank}{SummarizedExperiment}(
  x,
  rank = taxonomyRanks(x)[1],
  onRankOnly = FALSE,
  na.rm = FALSE,
  empty.fields = c(NA, "", " ", "\\t", "-", "_"),
  ...
)

\S4method{agglomerateByVariable}{SummarizedExperiment}(x, MARGIN, f, archetype = 1L, ...)

\S4method{agglomerateByVariable}{TreeSummarizedExperiment}(
  x,
  MARGIN,
  f,
  archetype = 1L,
  mergeTree = FALSE,
  mergeRefSeq = FALSE,
  ...
)

\S4method{mergeFeaturesByRank}{SummarizedExperiment}(
  x,
  rank = taxonomyRanks(x)[1],
  onRankOnly = FALSE,
  na.rm = FALSE,
  empty.fields = c(NA, "", " ", "\\t", "-", "_"),
  ...
)

\S4method{agglomerateByRank}{SingleCellExperiment}(x, ..., altexp = NULL, strip_altexp = TRUE)

\S4method{mergeFeaturesByRank}{SingleCellExperiment}(x, ..., altexp = NULL, strip_altexp = TRUE)

\S4method{agglomerateByRank}{TreeSummarizedExperiment}(
  x,
  ...,
  agglomerate.tree = agglomerateTree,
  agglomerateTree = FALSE
)

\S4method{mergeFeaturesByRank}{TreeSummarizedExperiment}(x, ..., agglomerate.tree = FALSE)
}
\arguments{
\item{x}{a \code{\link[SummarizedExperiment:SummarizedExperiment-class]{SummarizedExperiment}} or
a \code{\link[TreeSummarizedExperiment:TreeSummarizedExperiment-class]{TreeSummarizedExperiment}}}

\item{...}{arguments passed to \code{agglomerateByRank} function for
\code{SummarizedExperiment} objects,
\code{\link[=agglomerate-methods]{agglomerateByVariable}} and
\code{\link[scuttle:sumCountsAcrossFeatures]{sumCountsAcrossFeatures}}
with the exception of \code{subset_row}, \code{subset_col}.
\itemize{
\item{\code{remove_empty_ranks}}{A single boolean value for selecting
whether to remove those columns of rowData that include only NAs after
agglomeration. (By default: \code{remove_empty_ranks = FALSE})}
\item{\code{make_unique}}{A single boolean value for selecting
whether to make rownames unique.
(By default: \code{make_unique = TRUE})}
}}

\item{rank}{a single character defining a taxonomic rank. Must be a value of
\code{taxonomyRanks()} function.}

\item{onRankOnly}{\code{TRUE} or \code{FALSE}: Should information only from
the specified rank be used or from ranks equal and above? See details.
(default: \code{onRankOnly = FALSE})}

\item{na.rm}{\code{TRUE} or \code{FALSE}: Should taxa with an empty rank be
removed? Use it with caution, since empty entries on the selected rank
will be dropped. This setting can be tweaked by defining
\code{empty.fields} to your needs. (default: \code{na.rm = TRUE})}

\item{empty.fields}{a \code{character} value defining, which values should be
regarded as empty. (Default: \code{c(NA, "", " ", "\t")}). They will be
removed if \code{na.rm = TRUE} before agglomeration.}

\item{MARGIN}{A character value for selecting if data is merged
row-wise / for features ('rows') or column-wise / for samples ('cols').
Must be \code{'rows'} or \code{'cols'}.}

\item{f}{A factor for merging. Must be the same length as
\code{nrow(x)/ncol(x)}. Rows/Cols corresponding to the same level will be
merged. If \code{length(levels(f)) == nrow(x)/ncol(x)}, \code{x} will be
returned unchanged.}

\item{archetype}{Of each level of \code{f}, which element should be regarded
as the archetype and metadata in the columns or rows kept, while merging?
This can be single integer value or an integer vector of the same length
as \code{levels(f)}. (Default: \code{archetype = 1L}, which means the first
element encountered per factor level will be kept)}

\item{mergeTree}{\code{TRUE} or \code{FALSE}: Should
\code{rowTree()} also be merged? (Default: \code{mergeTree = FALSE})}

\item{mergeRefSeq}{\code{TRUE} or \code{FALSE}: Should a consensus sequence
be calculated? If set to \code{FALSE}, the result from \code{archetype} is
returned; If set to \code{TRUE} the result from
\code{\link[DECIPHER:ConsensusSequence]{DECIPHER::ConsensusSequence}} is
returned. (Default: \code{mergeRefSeq = FALSE})}

\item{altexp}{String or integer scalar specifying an alternative experiment
containing the input data.}

\item{strip_altexp}{\code{TRUE} or \code{FALSE}: Should alternative
experiments be removed prior to agglomeration? This prevents to many
nested alternative experiments by default (default:
\code{strip_altexp = TRUE})}

\item{agglomerate.tree}{\code{TRUE} or \code{FALSE}: should
\code{rowTree()} also be agglomerated? (Default:
\code{agglomerate.tree = FALSE})}

\item{agglomerateTree}{alias for \code{agglomerate.tree}.}
}
\value{
\code{agglomerateByRank} returns a taxonomically-agglomerated,
optionally-pruned object of the same class as \code{x} while
\code{agglomerateByVariable} returns an object of the same class as \code{x}
with the specified entries merged into one entry in all relevant components.
}
\description{
\code{agglomerateByRank} can be used to sum up data based on associations
with certain taxonomic ranks, as defined in \code{rowData}. Only available
\code{\link{taxonomyRanks}} can be used.
}
\details{
\code{agglomerateByVariable} merges data on rows or columns of a
\code{SummarizedExperiment} as defined by a \code{factor} alongside the
chosen dimension. Metadata from the \code{rowData} or \code{colData} are
retained as defined by \code{archetype}.
\code{\link[SummarizedExperiment:SummarizedExperiment-class]{assay}} are
agglomerated, i.e. summed up. If the assay contains values other than counts
or absolute values, this can lead to meaningless values being produced.

Depending on the available taxonomic data and its structure, setting
\code{onRankOnly = TRUE} has certain implications on the interpretability of
your results. If no loops exist (loops meaning two higher ranks containing
the same lower rank), the results should be comparable. You can check for
loops using \code{\link[TreeSummarizedExperiment:detectLoop]{detectLoop}}.

Agglomeration sums up the values of assays at the specified taxonomic level.
With certain assays, e.g. those that include binary or negative values, this
summing can produce meaningless values. In those cases, consider performing
agglomeration first, and then applying the transformation afterwards.

\code{agglomerateByVariable} works similarly to
\code{\link[scuttle:sumCountsAcrossFeatures]{sumCountsAcrossFeatures}}.
However, additional support for \code{TreeSummarizedExperiment} was added and
science field agnostic names were used. In addition the \code{archetype}
argument lets the user select how to preserve row or column data.

For merge data of assays the function from \code{scuttle} are used.
}
\examples{

### Agglomerate data based on taxonomic information

data(GlobalPatterns)
# print the available taxonomic ranks
colnames(rowData(GlobalPatterns))
taxonomyRanks(GlobalPatterns)

# agglomerate at the Family taxonomic rank
x1 <- agglomerateByRank(GlobalPatterns, rank="Family")
## How many taxa before/after agglomeration?
nrow(GlobalPatterns)
nrow(x1)

# agglomerate the tree as well
x2 <- agglomerateByRank(GlobalPatterns, rank="Family",
                       agglomerate.tree = TRUE)
nrow(x2) # same number of rows, but
rowTree(x1) # ... different
rowTree(x2) # ... tree

If assay contains binary or negative values, summing might lead to 
meaningless values, and you will get a warning. In these cases, you might 
want to do agglomeration again at chosen taxonomic level.
tse <- transformAssay(GlobalPatterns, method = "pa")
tse <- agglomerateByRank(tse, rank = "Genus")
tse <- transformAssay(tse, method = "pa")

# removing empty labels by setting na.rm = TRUE
sum(is.na(rowData(GlobalPatterns)$Family))
x3 <- agglomerateByRank(GlobalPatterns, rank="Family", na.rm = TRUE)
nrow(x3) # different from x2

# Because all the rownames are from the same rank, rownames do not include 
# prefixes, in this case "Family:". 
print(rownames(x3[1:3,]))

# To add them, use getTaxonomyLabels function.
rownames(x3) <- getTaxonomyLabels(x3, with_rank = TRUE)
print(rownames(x3[1:3,]))

# use 'remove_empty_ranks' to remove columns that include only NAs
x4 <- agglomerateByRank(GlobalPatterns, rank="Phylum", 
                        remove_empty_ranks = TRUE)
head(rowData(x4))

# If the assay contains NAs, you might want to consider replacing them,
# since summing-up NAs lead to NA
x5 <- GlobalPatterns
# Replace first value with NA
assay(x5)[1,1] <- NA
x6 <- agglomerateByRank(x5, "Kingdom")
head( assay(x6) )
# Replace NAs with 0. This is justified when we are summing-up counts.
assay(x5)[ is.na(assay(x5)) ] <- 0
x6 <- agglomerateByRank(x5, "Kingdom")
head( assay(x6) )

## Look at enterotype dataset...
data(enterotype)
## Print the available taxonomic ranks. Shows only 1 available rank,
## not useful for agglomerateByRank
taxonomyRanks(enterotype)

### Merge TreeSummarizedExperiments on rows and columns

data(esophagus)
esophagus
plot(rowTree(esophagus))
# get a factor for merging
f <- factor(regmatches(rownames(esophagus),
                       regexpr("^[0-9]*_[0-9]*",rownames(esophagus))))
merged <- agglomerateByVariable(esophagus, MARGIN = "rows", f, 
                                mergeTree = TRUE)
plot(rowTree(merged))
#
data(GlobalPatterns)
GlobalPatterns
merged <- agglomerateByVariable(GlobalPatterns, MARGIN = "cols", 
                                colData(GlobalPatterns)$SampleType)
merged
}
\seealso{
\code{\link[scuttle:sumCountsAcrossFeatures]{sumCountsAcrossFeatures}}
}
