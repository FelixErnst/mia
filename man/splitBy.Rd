% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/splitBy.R
\name{splitBy}
\alias{splitBy}
\alias{splitBy,SingleCellExperiment-method}
\alias{unsplitBy}
\alias{unsplitBy,list-method}
\alias{unsplitBy,SimpleList-method}
\title{Split \code{SummarizedExperiment} column-wise or row-wise based on grouping variable}
\usage{
splitBy(x, grouping = NULL, MARGIN = NULL, agglomerate = TRUE, ...)

\S4method{splitBy}{SingleCellExperiment}(x, grouping = NULL, MARGIN = NULL, agglomerate = TRUE, ...)

unsplitBy(x, MARGIN = NULL, ...)

\S4method{unsplitBy}{list}(x, MARGIN = NULL, ...)

\S4method{unsplitBy}{SimpleList}(x, MARGIN = NULL, ...)
}
\arguments{
\item{x}{A list of
\code{\link[SummarizedExperiment:SummarizedExperiment-class]{SummarizedExperiment}}
objects}

\item{grouping}{A single character value for selecting the grouping variable
from \code{colData} or \code{rowData}.}

\item{MARGIN}{A single numeric value, 1 (row) or 2 (col),  for selecting from
where grouping variable should be searched.}

\item{agglomerate}{A single boolean value to select whether to agglomerate the
data or not. (By default: \code{agglomerate = TRUE})}

\item{...}{Arguments passed to \code{agglomerateByRank} function for
\code{SummarizedExperiment} objects and other functions.
See \code{\link[=agglomerate-methods]{agglomerateByRank}} for more details.
\itemize{
\item{\code{use_names} A single boolean value to select whether to name elements of
list by their group names.}
}}
}
\value{
If the data is agglomerated, the result is a single \code{SummarizedExperiment}
object. If the data is not agglomerated, the result is a list of
\code{SummarizedExperiment} objects in \code{SimpleList} format.
}
\description{
Split \code{SummarizedExperiment} column-wise or row-wise based on grouping variable
}
\details{
\code{splitBy} split data based on grouping variable. Splitting can be done
column-wise or row-wise. You can specify if you want to agglomerate the data or not.

If data is agglomerated the returned value is a \code{SummarizedExperiment}
object that has values ummed-up based on grouping variable.

If data is not agglomerated, the returned value is a list of
\code{SummarizedExperiment} objects; each element containing members of each group.
}
\examples{
data(GlobalPatterns)
tse <- GlobalPatterns
# Split data based on SampleType. 
se_list <- splitBy(tse, grouping = "SampleType", agglomerate = FALSE)

se_list

# You can also agglomerate (sum-up) data based on grouping variable
se <- splitBy(tse, grouping = "SampleType")

# Create arbitrary groups
colData(tse)$group <- sample(1:10, ncol(tse), replace = TRUE)
rowData(tse)$group <- sample(1:10, nrow(tse), replace = TRUE)

# If variable named equally can be found from both colData and rowData, 
# MARGIN must be specified
se_ <- splitBy(tse, grouping = "group", MARGIN = 2, agglomerate = TRUE)

# It is possible to split data also in row-wise. 
se <- splitBy(tse, grouping = "group", MARGIN = 1, agglomerate = TRUE)

# Split data based on Phyla. If agglomerate = TRUE, 
# splitBy equals to agglomerateByRank
se <- splitBy(tse, "Phylum", agglomerate = TRUE)

se

# Split data withtout agglomeration
se_list <- splitBy(tse, "Phylum", agglomerate = FALSE)

se_list

# List of SE objects is returned. 
# Each element is named based on their group name. If you don't want to name
# elements, use use_name = FALSE
se_list <- splitBy(tse, grouping = "SampleType", use_name = FALSE, agglomerate = FALSE)

# If you want to combine groups back together, you can use unsplitBy
unsplitBy(se_list)

}
\seealso{
\code{\link[=splitByRanks]{splitByRanks}}
\code{\link[=unsplitByRanks]{unsplitByRanks}}
\code{\link[=merge-methods]{mergeRows}},
\code{\link[scuttle:sumCountsAcrossFeatures]{sumCountsAcrossFeatures}},
\code{\link[=agglomerate-methods]{agglomerateByRank}},
\code{\link[SingleCellExperiment:altExps]{altExps}},
\code{\link[SingleCellExperiment:splitAltExps]{splitAltExps}}
}
\author{
Leo Lahti and Tuomas Borman. Contact: \url{microbiome.github.io}
}
